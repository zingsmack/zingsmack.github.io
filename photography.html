<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>3D Photography Showcase</title>
  <style>
    html, body { margin: 0; padding: 0; overflow-x: hidden; }
    #renderCanvas { width: 100vw; height: 100vh; display: block; position: fixed; top: 0; left: 0; }
    .spacer { height: 1000vh; /* doubled scroll length */ }
  </style>
</head>
<body>
  <canvas id="renderCanvas"></canvas>
  <div class="spacer"></div>

  <!-- BabylonJS & GSAP Libraries -->
  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.11.5/gsap.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.11.5/ScrollTrigger.min.js"></script>

  <script>
    // Engine & Scene Setup
    const canvas = document.getElementById('renderCanvas');
    const engine = new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true });
    const scene = new BABYLON.Scene(engine);
    scene.clearColor = new BABYLON.Color4(0.03, 0.01, 0.08, 1);

    // Camera
    const camera = new BABYLON.FreeCamera('camera1', new BABYLON.Vector3(0, 0, 0), scene);
    camera.attachControl(canvas, true);

    // Lighting
    const hemiLight = new BABYLON.HemisphericLight('hemiLight', new BABYLON.Vector3(0, 1, 0), scene);
    hemiLight.intensity = 0.7;

    // Parameters
    const frameCount = 10;
    const samples = 300;
    const totalLength = frameCount * 15 * 2 + 40;

    // Create winding tube path
    const tubePath = [];
    for (let i = 0; i <= samples; i++) {
      const t = i / samples;
      const z = t * totalLength;
      const x = Math.sin(t * Math.PI * 4) * 8;
      const y = Math.cos(t * Math.PI * 3) * 5;
      tubePath.push(new BABYLON.Vector3(x, y, z));
    }
    const tube = BABYLON.MeshBuilder.CreateTube('tube', { path: tubePath, radius: 6, tessellation: 64, sideOrientation: BABYLON.Mesh.DOUBLESIDE }, scene);
    const tubeMat = new BABYLON.StandardMaterial('tubeMat', scene);
    tubeMat.emissiveColor = new BABYLON.Color3(0.2, 0.1, 0.5);
    tubeMat.alpha = 0.15;
    tube.material = tubeMat;

    // Setup frames along the tube
    const frames = [];
    for (let i = 0; i < frameCount; i++) {
      // Create frame group
      const group = new BABYLON.TransformNode('frameGroup' + i, scene);
      const border = BABYLON.MeshBuilder.CreateBox('border' + i, { width: 3, height: 2, depth: 0.1 }, scene);
      border.parent = group;
      border.renderOutline = true;
      border.outlineColor = BABYLON.Color3.White();
      border.outlinesWidth = 0.05;
      const mat = new BABYLON.StandardMaterial('frameMat' + i, scene);
      mat.diffuseColor = new BABYLON.Color3(0.7 + Math.random() * 0.3, 0.2 + Math.random() * 0.5, 0.5 + Math.random() * 0.4);
      border.material = mat;
      // Inner plane for images/text
      const plane = BABYLON.MeshBuilder.CreatePlane('plane' + i, { width: 2.5, height: 1.5 }, scene);
      plane.parent = group;
      plane.position.z = 0.06;
      const dt = new BABYLON.DynamicTexture('dt' + i, { width: 512, height: 256 }, scene, false);
      dt.drawText('Your Image Here', null, 140, 'bold 36px monospace', '#FFFFFF', 'transparent', true);
      const dtMat = new BABYLON.StandardMaterial('dtMat' + i, scene);
      dtMat.diffuseTexture = dt;
      dtMat.emissiveColor = new BABYLON.Color3(1, 1, 1);
      plane.material = dtMat;
      // Position along tube path
      const idx = Math.floor((i + 1) * (samples / (frameCount + 1)));
      group.position.copyFrom(tubePath[idx]);
      // Store
      frames.push(group);
    }

    // Add random trippy objects, spaced further apart
    const shapes = ['box', 'sphere', 'torus', 'cylinder'];
    for (let i = 0; i < 60; i++) {
      const type = shapes[Math.floor(Math.random() * shapes.length)];
      let mesh;
      switch (type) {
        case 'box': mesh = BABYLON.MeshBuilder.CreateBox('obj' + i, { size: 2 }, scene); break;
        case 'sphere': mesh = BABYLON.MeshBuilder.CreateSphere('obj' + i, { diameter: 2.5 }, scene); break;
        case 'torus': mesh = BABYLON.MeshBuilder.CreateTorus('obj' + i, { diameter: 2, thickness: 0.5 }, scene); break;
        case 'cylinder': mesh = BABYLON.MeshBuilder.CreateCylinder('obj' + i, { diameter: 1.5, height: 3 }, scene); break;
      }
      // Increase spatial range
      const px = (Math.random() - 0.5) * 40;
      const py = (Math.random() - 0.5) * 20;
      const pz = Math.random() * totalLength;
      mesh.position = new BABYLON.Vector3(px, py, pz);
      mesh.rotation = new BABYLON.Vector3(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
      const mmat = new BABYLON.StandardMaterial('omat' + i, scene);
      mmat.emissiveColor = new BABYLON.Color3(Math.random(), Math.random(), Math.random());
      mesh.material = mmat;
    }

    // ScrollTrigger to move camera through tube
    gsap.registerPlugin(ScrollTrigger);
    gsap.to({}, {
      scrollTrigger: {
        trigger: '.spacer',
        start: 'top top',
        end: 'bottom bottom',
        scrub: true,
        onUpdate: self => {
          const prog = self.progress;
          const idx = Math.floor(prog * samples);
          camera.position.copyFrom(tubePath[idx]);
          const next = tubePath[Math.min(idx + 1, samples)];
          camera.setTarget(next);
          // Slight frame rotation
          frames.forEach((fg, i) => fg.rotation.y = prog * Math.PI * 2 * ((i % 2) ? -1 : 1));
        }
      }
    });

    // Render Loop & Resize
    engine.runRenderLoop(() => scene.render());
    window.addEventListener('resize', () => engine.resize());

    /*
      CUSTOMIZATION:
      - Replace 'Your Image Here' and use BABYLON.Texture('path/to.jpg', scene) on plane.material.diffuseTexture.
      - Adjust 'px'/'py' multipliers to change object spread.
    */
  </script>
</body>
</html>
