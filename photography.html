<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>3D Photography Showcase</title>
  <style>
    html, body { margin: 0; padding: 0; }
    canvas { display: block; position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; }
    .spacer { height: 1000vh; /* Scroll length */ }
  </style>
</head>
<body>
  <canvas id="renderCanvas"></canvas>
  <div class="spacer"></div>

  <!-- Libraries -->
  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.11.5/gsap.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.11.5/ScrollTrigger.min.js"></script>

<script>
// Initialize Babylon
const canvas = document.getElementById('renderCanvas');
const engine = new BABYLON.Engine(canvas, true);
const scene = new BABYLON.Scene(engine);
scene.clearColor = new BABYLON.Color4(0.03, 0.01, 0.08, 1);

// Camera
const camera = new BABYLON.FreeCamera('cam', new BABYLON.Vector3(0,0,0), scene);
camera.attachControl(canvas,true);

// Light
new BABYLON.HemisphericLight('light', new BABYLON.Vector3(0,1,0), scene);

// Define tunnel path using parametric Z-based calculation
const maxZ = 150;
function getPoint(t) {
  // t from 0 to 1
  return new BABYLON.Vector3(
    Math.sin(2 * Math.PI * t) * 8,
    Math.cos(2 * Math.PI * t) * 4,
    t * maxZ
  );
}
// Draw semi-transparent tube
const steps = 200;
const path = [];
for(let i=0;i<=steps;i++){ path.push(getPoint(i/steps)); }
const tube = BABYLON.MeshBuilder.CreateTube('t', {path, radius:6, sideOrientation: BABYLON.Mesh.DOUBLESIDE}, scene);
tube.material = new BABYLON.StandardMaterial('m',scene);
tube.material.alpha = 0.1;

// Create frames
const frames = [];
const count = 10;
for(let i=0;i<count;i++){
  const t = (i+1)/(count+1);
  const pos = getPoint(t);
  const node = new BABYLON.TransformNode('f'+i,scene);
  node.position = pos;
  // border
  const b = BABYLON.MeshBuilder.CreateBox('b'+i,{width:2,height:3,depth:0.1},scene);
  b.parent = node;
  b.renderOutline = true; b.outlineColor.set(1,1,1); b.outlinesWidth=0.05;
  // plane
  const p = BABYLON.MeshBuilder.CreatePlane('p'+i,{width:1.8,height:2.8},scene);
  p.parent = node; p.position.z=0.06;
  const dt = new BABYLON.DynamicTexture('dt'+i,{width:512,height:768},scene);
  dt.drawText('Your Portrait',50,400,'bold 48px Arial','#FFF','transparent');
  const mat = new BABYLON.StandardMaterial('mat'+i,scene);
  mat.diffuseTexture = dt; mat.emissiveColor.set(1,1,1);
  // frames now always face the camera via billboardMode; no manual rotation needed;
  frames.push(node);
}

// GSAP scroll animation
gsap.registerPlugin(ScrollTrigger);
const proxy = {t:0};
gsap.to(proxy, {
  t:1,
  ease:'none',
  scrollTrigger: {
    trigger: '.spacer', start:'top top', end:'bottom bottom', scrub:true,
  },
  onUpdate() {
    const t = proxy.t;
    // move camera
    const pos = getPoint(t);
    camera.position.copyFrom(pos);
    // look ahead
    const ahead = getPoint(Math.min(t+1/steps,1));
    camera.setTarget(ahead);
    // rotate frames
    frames.forEach((n,i)=> n.rotation.y = proxy.t * Math.PI * 2 * ((i%2)?-1:1));
  }
});

// Render loop
engine.runRenderLoop(()=>scene.render());
window.addEventListener('resize',()=>engine.resize());
</script>
</body>
</html>
