<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>3D Photography Showcase</title>
  <style>
    html, body { margin: 0; padding: 0; overflow-x: hidden; }
    #renderCanvas { width: 100vw; height: 100vh; display: block; position: fixed; top: 0; left: 0; }
    .spacer { height: 1000vh; }
  </style>
</head>
<body>
  <canvas id="renderCanvas"></canvas>
  <div class="spacer"></div>

  <!-- BabylonJS & GSAP Libraries -->
  <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <!-- glTF loader for .glb support -->
    <script src="https://cdn.babylonjs.com/loaders/babylon.glTF2FileLoader.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.11.5/gsap.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.11.5/ScrollTrigger.min.js"></script>

  <script>
    // Engine & Scene Setup
    const canvas = document.getElementById('renderCanvas');
    const engine = new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true });
    const scene = new BABYLON.Scene(engine);
    scene.clearColor = new BABYLON.Color4(0.03, 0.01, 0.08, 1);

    // Camera
    const camera = new BABYLON.FreeCamera('camera1', new BABYLON.Vector3(0, 0, 0), scene);
    camera.attachControl(canvas, true);

    // Lighting
    const hemiLight = new BABYLON.HemisphericLight('hemiLight', new BABYLON.Vector3(0, 1, 0), scene);
    hemiLight.intensity = 0.7;

    // Parameters
    const frameCount = 10;
    const samples = 300;
    const totalLength = frameCount * 15 * 2 + 40;

    // Tube path
    const tubePath = [];
    for (let i = 0; i <= samples; i++) {
      const t = i / samples;
      tubePath.push(new BABYLON.Vector3(
        Math.sin(t * Math.PI * 4) * 8,
        Math.cos(t * Math.PI * 3) * 5,
        t * totalLength
      ));
    }
    const tube = BABYLON.MeshBuilder.CreateTube('tube', { path: tubePath, radius: 6, tessellation: 64, sideOrientation: BABYLON.Mesh.DOUBLESIDE }, scene);
    const tubeMat = new BABYLON.StandardMaterial('tubeMat', scene);
    tubeMat.emissiveColor = new BABYLON.Color3(0.2, 0.1, 0.5);
    tubeMat.alpha = 0.15;
    tube.material = tubeMat;

    // Portrait frames
    const frames = [];
    for (let i = 0; i < frameCount; i++) {
      const group = new BABYLON.TransformNode('frameGroup' + i, scene);
      const border = BABYLON.MeshBuilder.CreateBox('border' + i, { width: 2, height: 3, depth: 0.1 }, scene);
      border.parent = group;
      border.renderOutline = true;
      border.outlineColor = BABYLON.Color3.White();
      border.outlinesWidth = 0.05;
      const mat = new BABYLON.StandardMaterial('frameMat' + i, scene);
      mat.diffuseColor = new BABYLON.Color3(
        0.7 + Math.random() * 0.3,
        0.2 + Math.random() * 0.5,
        0.5 + Math.random() * 0.4
      );
      border.material = mat;

      const plane = BABYLON.MeshBuilder.CreatePlane('plane' + i, { width: 1.8, height: 2.8 }, scene);
      plane.parent = group;
      plane.position.z = 0.06;
      const dt = new BABYLON.DynamicTexture('dt' + i, { width: 512, height: 768 }, scene, false);
      dt.drawText('Portrait Here', null, 400, 'bold 48px monospace', '#FFFFFF', 'transparent', true);
      const dtMat = new BABYLON.StandardMaterial('dtMat' + i, scene);
      dtMat.diffuseTexture = dt;
      dtMat.emissiveColor = new BABYLON.Color3(1, 1, 1);
      plane.material = dtMat;

      const idx = Math.floor((i + 1) * samples / (frameCount + 1));
      group.position.copyFrom(tubePath[idx]);
      frames.push(group);
    }

    // Trippy background objects
    const shapes = ['box','sphere','torus','cylinder'];
    for (let i = 0; i < 60; i++) {
      const mesh = BABYLON.MeshBuilder[{
        box: 'CreateBox', sphere: 'CreateSphere', torus: 'CreateTorus', cylinder: 'CreateCylinder'
      }[shapes[i % shapes.length]]](
        'obj'+i,
        shapes[i % shapes.length] === 'sphere' ? { diameter: 2.5 } : shapes[i % shapes.length] === 'torus' ? { diameter:2, thickness:0.5 } : shapes[i % shapes.length] === 'cylinder' ? { diameter:1.5,height:3 } : { size:2 },
        scene
      );
      mesh.position = new BABYLON.Vector3((Math.random()-0.5)*40,(Math.random()-0.5)*20,Math.random()*totalLength);
      mesh.rotation = new BABYLON.Vector3(Math.random()*Math.PI,Math.random()*Math.PI,Math.random()*Math.PI);
      const mmat = new BABYLON.StandardMaterial('omat'+i,scene);
      mmat.emissiveColor = new BABYLON.Color3(Math.random(),Math.random(),Math.random());
      mesh.material = mmat;
    }

    // Cat head model
    let catMesh = null;
    BABYLON.SceneLoader.ImportMesh('', 'https://models.babylonjs.com/Cat.glb', '', scene, meshes => {
      catMesh = meshes[0];
      catMesh.position = new BABYLON.Vector3(10,0,totalLength*0.5);
      catMesh.scaling = new BABYLON.Vector3(0.5,0.5,0.5);
    });

    // Scroll-triggered animation
    gsap.registerPlugin(ScrollTrigger);
    gsap.to({}, {
      scrollTrigger: {
        trigger: '.spacer', start: 'top top', end: 'bottom bottom', scrub: true,
        onUpdate: self => {
          const prog = self.progress;
          const idx = Math.floor(prog * samples);
          camera.position.copyFrom(tubePath[idx]);
          camera.setTarget(tubePath[Math.min(idx+1,samples)]);
          frames.forEach((fg,i) => fg.rotation.y = prog*Math.PI*2*((i%2)?-1:1));
          if(catMesh) catMesh.rotation.y = prog * Math.PI * 4;
        }
      }
    });

    engine.runRenderLoop(() => scene.render());
    window.addEventListener('resize', () => engine.resize());
  </script>
</body>
</html>
