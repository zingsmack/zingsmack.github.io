<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Three.js Organic Bloom Animation</title>
  <style>
    body { margin: 0; overflow: hidden; background: #000; }
    canvas { display: block; }
  </style>
</head>
<body>
<script type="module">
  import * as THREE from './js/libs/three.module.js';
  import { EffectComposer } from './js/libs/examples/jsm/postprocessing/EffectComposer.js';
  import { RenderPass } from './js/libs/examples/jsm/postprocessing/RenderPass.js';
  import { UnrealBloomPass } from './js/libs/examples/jsm/postprocessing/UnrealBloomPass.js';
  import { RGBELoader } from './js/libs/examples/jsm/loaders/RGBELoader.js';

  let scene, camera, renderer, clock, composer;
  const bloomGroup = new THREE.Group();
  const bubbleGroup = new THREE.Group();
  const mushroomGroup = new THREE.Group();
  const budGroup = new THREE.Group();

  const palettes = [
    [new THREE.Color(0xffc0cb), new THREE.Color(0x98ff98), new THREE.Color(0xffe4b5)],
    [new THREE.Color(0xff69b4), new THREE.Color(0x7fffd4), new THREE.Color(0xffd700)],
    [new THREE.Color(0xda70d6), new THREE.Color(0x00ced1), new THREE.Color(0xff8c00)]
  ];

  init();
  animate();

  function init() {
    // Scene & Camera
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 0, 100);

    // Renderer
    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);
    window.addEventListener('resize', onWindowResize);

    // Clock
    clock = new THREE.Clock();

    // Post-processing composer
    composer = new EffectComposer(renderer);
    composer.addPass(new RenderPass(scene, camera));
    const bloomPass = new UnrealBloomPass(
      new THREE.Vector2(window.innerWidth, window.innerHeight),
      0.8, 0.4, 0.85
    );
    composer.addPass(bloomPass);

    // Environment map (place an HDR at './js/env/env.hdr')
    const pmremGen = new THREE.PMREMGenerator(renderer);
    new RGBELoader()
      .setDataType(THREE.UnsignedByteType)
      .load('./js/env/env.hdr', hdr => {
        const envMap = pmremGen.fromEquirectangular(hdr).texture;
        scene.environment = envMap;
        scene.background = envMap;
        hdr.dispose();
        pmremGen.dispose();
      });

    // Add groups
    scene.add(bloomGroup, bubbleGroup, mushroomGroup, budGroup);

    // Lighting
    scene.add(new THREE.AmbientLight(0xffffff, 0.3));
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.7);
    dirLight.position.set(1, 1, 1);
    scene.add(dirLight);

    // Create blooms
    for (let i = 0; i < 6; i++) {
      const size = 20 + Math.random() * 30;
      const count = 6 + Math.floor(Math.random() * 4);
      const bloom = createBloom(size, count, palettes[i % palettes.length]);
      bloom.position.set(
        (Math.random() - 0.5) * 80,
        (Math.random() - 0.5) * 60,
        (Math.random() - 0.5) * 20
      );
      bloomGroup.add(bloom);
    }

    // Create bubbles
    const bubbleGeo = new THREE.SphereGeometry(1.5, 16, 12);
    for (let i = 0; i < 50; i++) {
      const mat = new THREE.MeshStandardMaterial({
        color: 0xffffff,
        emissive: 0xffffff,
        emissiveIntensity: 0.6,
        transparent: true,
        opacity: 0.5
      });
      const bubble = new THREE.Mesh(bubbleGeo, mat);
      bubble.position.set(
        (Math.random() - 0.5) * 80,
        (Math.random() - 0.5) * 60,
        (Math.random() - 0.5) * 20
      );
      bubble.userData.vel = new THREE.Vector3(0, 0.1 + Math.random() * 0.2, 0);
      bubbleGroup.add(bubble);
    }

    // Create mushrooms
    for (let i = 0; i < 20; i++) {
      const stemH = 5 + Math.random() * 10;
      const stemGeo = new THREE.CylinderGeometry(0.5, 1, stemH, 12);
      const stemMat = new THREE.MeshStandardMaterial({ color: 0xdeb887, roughness: 0.8 });
      const stem = new THREE.Mesh(stemGeo, stemMat);
      stem.position.set(
        (Math.random() - 0.5) * 80,
        (Math.random() - 0.5) * 60,
        (Math.random() - 0.5) * 20
      );
      mushroomGroup.add(stem);

      const capGeo = new THREE.SphereGeometry(1.5 + Math.random() * 3, 16, 12, 0, Math.PI);
      const pal = palettes[i % palettes.length];
      const capMat = new THREE.ShaderMaterial({
        vertexShader,
        fragmentShader,
        uniforms: {
          uTime: { value: 0 },
          colorA: { value: pal[0] },
          colorB: { value: pal[1] },
          colorC: { value: pal[2] }
        },
        side: THREE.DoubleSide
      });
      const cap = new THREE.Mesh(capGeo, capMat);
      cap.position.copy(stem.position).add(new THREE.Vector3(0, stemH / 2, 0));
      cap.rotation.x = Math.PI;
      mushroomGroup.add(cap);
    }

    // Create bud clusters
    const budGeo = new THREE.SphereGeometry(2, 12, 8);
    for (let i = 0; i < 100; i++) {
      const pal = palettes[i % palettes.length];
      const budMat = new THREE.ShaderMaterial({
        vertexShader,
        fragmentShader,
        uniforms: {
          uTime: { value: 0 },
          colorA: { value: pal[0] },
          colorB: { value: pal[1] },
          colorC: { value: pal[2] }
        },
        side: THREE.DoubleSide
      });
      const bud = new THREE.Mesh(budGeo, budMat);
      bud.position.set(
        (Math.random() - 0.5) * 80,
        (Math.random() - 0.5) * 60,
        (Math.random() - 0.5) * 20
      );
      budGroup.add(bud);
    }
  }

  // Shader code
  const vertexShader = `
    uniform float uTime;
    varying vec2 vUv;
    varying float vUvY;
    
    float random(vec2 st) {
      return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
    }
    float noise(vec2 st) {
      vec2 i = floor(st);
      vec2 f = fract(st);
      vec2 u = f * f * (3.0 - 2.0 * f);
      return mix(
        mix(random(i + vec2(0.0)), random(i + vec2(1.0)), u.x),
        mix(random(i + vec2(0.0,1.0)), random(i + vec2(1.0,1.0)), u.x),
        u.y
      );
    }
    void main() {
      vUv = uv;
      vUvY = uv.y;
      float n = noise(uv * 5.0 + uTime * 0.3);
      vec3 displaced = position + normal * n * 2.5;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(displaced, 1.0);
    }
  `;

  const fragmentShader = `
    uniform vec3 colorA;
    uniform vec3 colorB;
    uniform vec3 colorC;
    varying float vUvY;
    void main() {
      vec3 col;
      if (vUvY < 0.5) {
        col = mix(colorA, colorB, vUvY * 2.0);
      } else {
        col = mix(colorB, colorC, (vUvY - 0.5) * 2.0);
      }
      gl_FragColor = vec4(col, 1.0);
    }
  `;

  function createBloom(radius, petals, palette) {
    const group = new THREE.Group();
    for (let i = 0; i < petals; i++) {
      const angle = (i / petals) * Math.PI * 2;
      const geom = createPetalGeometry(radius);
      geom.computeVertexNormals();
      const mat = new THREE.ShaderMaterial({
        vertexShader,
        fragmentShader,
        uniforms: {
          uTime: { value: 0 },
          colorA: { value: palette[0] },
          colorB: { value: palette[1] },
          colorC: { value: palette[2] }
        },
        side: THREE.DoubleSide
      });
      const mesh = new THREE.Mesh(geom, mat);
      mesh.rotation.z = angle;
      group.add(mesh);
    }
    return group;
  }

  function createPetalGeometry(radius) {
    const points = [];
    const seg = 16;
    for (let i = 0; i <= seg; i++) {
      const t = i / seg;
      const x = Math.sin(t * Math.PI) * radius;
      const y = Math.cos(t * Math.PI) * radius * 0.1;
      points.push(new THREE.Vector2(x, y));
    }
    return new THREE.LatheGeometry(points, 12);
  }

  function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    composer.setSize(window.innerWidth, window.innerHeight);
  }

  function animate() {
    requestAnimationFrame(animate);
    const t = clock.getElapsedTime();
    bloomGroup.children.forEach((bloom, i) => {
      bloom.children.forEach(petal => {
        petal.material.uniforms.uTime.value = t;
      });
    });
    bubbleGroup.children.forEach(bubble => {
      bubble.position.add(bubble.userData.vel);
      if (bubble.position.y > 60) bubble.position.y = -60;
    });
    mushroomGroup.children.forEach(m => {
      if (m.material && m.material.uniforms) m.material.uniforms.uTime.value = t;
    });
    budGroup.children.forEach(b => {
      b.material.uniforms.uTime.value = t;
    });
    composer.render();
  }
</script>
</body>
</html>
