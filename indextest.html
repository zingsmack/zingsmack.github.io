<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Three.js Organic Bloom Animation</title>
  <!-- Import map for local modules -->
  <script type="importmap">
  {
    "imports": {
      "three": "/js/libs/three.module.js",
      "three/examples/jsm/": "/js/libs/examples/jsm/"
    }
  }
  </script>
  <style>
    body { margin: 0; overflow: hidden; background: #000; }
    canvas { display: block; }
  </style>
</head>
<body>
<script type="module">
  import * as THREE from 'three';
  import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';
  import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js';
  import { UnrealBloomPass } from 'three/examples/jsm/postprocessing/UnrealBloomPass.js';
  import { RGBELoader } from 'three/examples/jsm/loaders/RGBELoader.js';

  // Shared variables
  let scene, camera, renderer, clock, composer;
  const bloomGroup = new THREE.Group();
  const bubbleGroup = new THREE.Group();
  const mushroomGroup = new THREE.Group();
  const budGroup = new THREE.Group();
  
  const palettes = [
    [0xffc0cb, 0x98ff98, 0xffe4b5],
    [0xff69b4, 0x7fffd4, 0xffd700],
    [0xda70d6, 0x00ced1, 0xff8c00]
  ].map(arr => arr.map(c => new THREE.Color(c)));

  init();
  animate();

  function init() {
    // Scene & Camera
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.set(0, 0, 100);

    // Renderer
    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputEncoding = THREE.sRGBEncoding;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.0;
    document.body.appendChild(renderer.domElement);
    window.addEventListener('resize', () => onWindowResize());

    // Clock
    clock = new THREE.Clock();

    // Composer & Bloom
    composer = new EffectComposer(renderer);
    composer.setPixelRatio(renderer.getPixelRatio());
    composer.setSize(window.innerWidth, window.innerHeight);
    composer.addPass(new RenderPass(scene, camera));
    const bloomPass = new UnrealBloomPass(
      new THREE.Vector2(window.innerWidth, window.innerHeight),
      1.2, 1.5, 0.6
    );
    composer.addPass(bloomPass);

    // Environment
    const pmremGen = new THREE.PMREMGenerator(renderer);
    pmremGen.compileEquirectangularShader();
    new RGBELoader()
      .setDataType(THREE.FloatType)
      .load('/js/env/env.hdr', (hdr) => {
        const envMap = pmremGen.fromEquirectangular(hdr).texture;
        scene.environment = envMap;
        scene.background = envMap;
        hdr.dispose();
        pmremGen.dispose();
      });

    // Add groups
    scene.add(bloomGroup, bubbleGroup, mushroomGroup, budGroup);
    scene.add(new THREE.AmbientLight(0xffffff, 0.3));
    const dir = new THREE.DirectionalLight(0xffffff, 0.7);
    dir.position.set(1,1,1);
    scene.add(dir);

    // Create elements spread out
    for(let i=0; i<6; i++){
      const bloom = createBloom(20 + Math.random()*30, 5 + Math.floor(Math.random()*5), palettes[i%palettes.length]);
      bloom.position.set((Math.random()-0.5)*150, (Math.random()-0.5)*100, (Math.random()-0.5)*50);
      bloomGroup.add(bloom);
    }
    const bubbleGeo = new THREE.SphereGeometry(1.5,16,12);
    const bubbleMat = new THREE.MeshToonMaterial({ color: 0xffffff, flatShading: true });
    for(let i=0;i<50;i++){
      const b = new THREE.Mesh(bubbleGeo, bubbleMat);
      b.position.set((Math.random()-0.5)*150,(Math.random()-0.5)*100,(Math.random()-0.5)*50);
      b.userData.vel = new THREE.Vector3(0,0.1+Math.random()*0.2,0);
      bubbleGroup.add(b);
    }
    for(let i=0;i<20;i++){
      const h = 5+Math.random()*10;
      const stem = new THREE.Mesh(
        new THREE.CylinderGeometry(0.5,1,h,12),
        new THREE.MeshToonMaterial({ color: 0xdeb887, flatShading: true })
      );
      stem.position.set((Math.random()-0.5)*150,(Math.random()-0.5)*100,(Math.random()-0.5)*50);
      mushroomGroup.add(stem);
      const cap = new THREE.Mesh(
        new THREE.SphereGeometry(1.5+Math.random()*3,16,12,0,Math.PI),
        new THREE.MeshToonMaterial({ color: palettes[i%palettes.length][1], flatShading:true })
      );
      cap.position.copy(stem.position).add(new THREE.Vector3(0,h/2,0));
      cap.rotation.x = Math.PI;
      mushroomGroup.add(cap);
    }
    const budGeo = new THREE.SphereGeometry(2,12,8);
    for(let i=0;i<100;i++){
      const mat = new THREE.MeshToonMaterial({ color: palettes[i%palettes.length][1], flatShading:true });
      const bud = new THREE.Mesh(budGeo, mat);
      bud.position.set((Math.random()-0.5)*150,(Math.random()-0.5)*100,(Math.random()-0.5)*50);
      budGroup.add(bud);
    }
  }

  function createBloom(radius, petals, colors){
    const grp = new THREE.Group();
    for(let i=0;i<petals;i++){
      const geom = new THREE.LatheGeometry(
        Array.from({length:17},(_,j)=>{
          const t=j/16;
          return new THREE.Vector2(Math.sin(t*Math.PI)*radius, Math.cos(t*Math.PI)*radius*0.1);
        }),12
      );
      const mat = new THREE.MeshToonMaterial({ color: colors[1], flatShading:true });
      const mesh = new THREE.Mesh(geom, mat);
      mesh.rotation.z = (i/petals)*Math.PI*2;
      grp.add(mesh);
    }
    return grp;
  }

  function onWindowResize(){
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    composer.setSize(window.innerWidth, window.innerHeight);
  }

  function animate(){
    requestAnimationFrame(animate);
    const delta = clock.getDelta();
    const t = clock.getElapsedTime();

    // Animate bubbles rising
    bubbleGroup.children.forEach(b => {
      b.position.add(b.userData.vel);
      if (b.position.y > 60) b.position.y = -60;
    });

    // Rotate entire bloom group slowly
    bloomGroup.rotation.y += delta * 0.1;
    // Subtle pulse on each bloom radius
    bloomGroup.children.forEach((bloom, i) => {
      const scale = 1 + 0.05 * Math.sin(t * 2 + i);
      bloom.scale.set(scale, scale, scale);
    });

    // Sway mushrooms
    mushroomGroup.children.forEach((stem, i) => {
      stem.rotation.z = 0.1 * Math.sin(t + i);
    });

    // Bud pulsation
    budGroup.children.forEach((bud, i) => {
      const s = 1 + 0.1 * Math.sin(t * 3 + i);
      bud.scale.set(s, s, s);
    });

    // Render scene with bloom
    composer.render();
  }
  
</script>
</body>
</html>
