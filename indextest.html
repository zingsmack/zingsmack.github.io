<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Three.js Organic Bloom Animation</title>
  <!-- Import map to resolve bare specifiers -->
  <script type="importmap">
{
  "imports": {
    "three": "/js/libs/three.module.js",
    "three/examples/jsm/": "/js/libs/examples/jsm/"
  }
}
</script>
  <!--
    Required example modules under js/libs/examples/jsm:

    postprocessing:
      - Pass.js
      - RenderPass.js
      - ShaderPass.js
      - MaskPass.js
      - EffectComposer.js
      - UnrealBloomPass.js

    shaders:
      - CopyShader.js
      - LuminosityHighPassShader.js
  -->
  <style>
    body { margin: 0; overflow: hidden; background: #000; }
    canvas { display: block; }
  </style>
</head>
<body>
<script type="module">
  import * as THREE from 'three';
  import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';
  import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js';
  import { ShaderPass } from 'three/examples/jsm/postprocessing/ShaderPass.js';
  import { MaskPass } from 'three/examples/jsm/postprocessing/MaskPass.js';
  import { UnrealBloomPass } from 'three/examples/jsm/postprocessing/UnrealBloomPass.js';
  import { RGBELoader } from 'three/examples/jsm/loaders/RGBELoader.js';

  let scene, camera, renderer, clock, composer;
  const bloomGroup = new THREE.Group();
  const bubbleGroup = new THREE.Group();
  const mushroomGroup = new THREE.Group();
  const budGroup = new THREE.Group();

  const palettes = [
    [new THREE.Color(0xffc0cb), new THREE.Color(0x98ff98), new THREE.Color(0xffe4b5)],
    [new THREE.Color(0xff69b4), new THREE.Color(0x7fffd4), new THREE.Color(0xffd700)],
    [new THREE.Color(0xda70d6), new THREE.Color(0x00ced1), new THREE.Color(0xff8c00)]
  ];

  init();
  animate();

  function init() {
    // Scene and camera
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 0, 100);

    // Renderer
    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);
    window.addEventListener('resize', onWindowResize);

    // Clock
    clock = new THREE.Clock();

    // Post-processing
    composer = new EffectComposer(renderer);
    composer.addPass(new RenderPass(scene, camera));
    // Bloom pass
    const bloomPass = new UnrealBloomPass(
      new THREE.Vector2(window.innerWidth, window.innerHeight),
      0.8, 0.4, 0.85
    );
    composer.addPass(bloomPass);

    // Environment HDR
    const pmremGen = new THREE.PMREMGenerator(renderer);
    new RGBELoader()
      .setDataType(THREE.UnsignedByteType)
      .load('./js/env/env.hdr', hdr => {
        const envMap = pmremGen.fromEquirectangular(hdr).texture;
        scene.environment = envMap;
        scene.background = envMap;
        hdr.dispose();
        pmremGen.dispose();
      });

    // Add groups
    scene.add(bloomGroup, bubbleGroup, mushroomGroup, budGroup);

    // Lights
    scene.add(new THREE.AmbientLight(0xffffff, 0.3));
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.7);
    dirLight.position.set(1, 1, 1);
    scene.add(dirLight);

    // Create blooms
    for (let i = 0; i < 6; i++) {
      const size = 20 + Math.random() * 30;
      const count = 6 + Math.floor(Math.random() * 4);
      const bloom = createBloom(size, count, palettes[i % palettes.length]);
      bloom.position.set(
        (Math.random() - 0.5) * 80,
        (Math.random() - 0.5) * 60,
        (Math.random() - 0.5) * 20
      );
      bloomGroup.add(bloom);
    }

    // Bubbles
    const bubbleGeo = new THREE.SphereGeometry(1.5, 16, 12);
    for (let i = 0; i < 50; i++) {
      const mat = new THREE.MeshStandardMaterial({
        color: 0xffffff,
        emissive: 0xffffff,
        emissiveIntensity: 0.6,
        transparent: true,
        opacity: 0.5
      });
      const bubble = new THREE.Mesh(bubbleGeo, mat);
      bubble.position.set(
        (Math.random() - 0.5) * 80,
        (Math.random() - 0.5) * 60,
        (Math.random() - 0.5) * 20
      );
      bubble.userData.vel = new THREE.Vector3(0, 0.1 + Math.random() * 0.2, 0);
      bubbleGroup.add(bubble);
    }

    // Mushrooms + caps
    for (let i = 0; i < 20; i++) {
      const stemH = 5 + Math.random() * 10;
      const stemGeo = new THREE.CylinderGeometry(0.5, 1, stemH, 12);
      const stemMat = new THREE.MeshStandardMaterial({ color: 0xdeb887, roughness: 0.8 });
      const stem = new THREE.Mesh(stemGeo, stemMat);
      stem.position.set(
        (Math.random() - 0.5) * 80,
        (Math.random() - 0.5) * 60,
        (Math.random() - 0.5) * 20
      );
      mushroomGroup.add(stem);

      const capGeo = new THREE.SphereGeometry(1.5 + Math.random() * 3, 16, 12, 0, Math.PI);
      const pal = palettes[i % palettes.length];
      const capMat = createShaderMaterial(pal);
      const cap = new THREE.Mesh(capGeo, capMat);
      cap.position.copy(stem.position).add(new THREE.Vector3(0, stemH / 2, 0));
      cap.rotation.x = Math.PI;
      mushroomGroup.add(cap);
    }

    // Bud clusters
    const budGeo = new THREE.SphereGeometry(2, 12, 8);
    for (let i = 0; i < 100; i++) {
      const pal = palettes[i % palettes.length];
      const budMat = createShaderMaterial(pal);
      const bud = new THREE.Mesh(budGeo, budMat);
      bud.position.set(
        (Math.random() - 0.5) * 80,
        (Math.random() - 0.5) * 60,
        (Math.random() - 0.5) * 20
      );
      budGroup.add(bud);
    }
  }

  // Shared shader material factory
  function createShaderMaterial(pal) {
    return new THREE.ShaderMaterial({
      vertexShader,
      fragmentShader,
      uniforms: {
        uTime: { value: 0 },
        colorA: { value: pal[0] },
        colorB: { value: pal[1] },
        colorC: { value: pal[2] }
      },
      side: THREE.DoubleSide
    });
  }

  // Shader code
  const vertexShader = `
    uniform float uTime;
    varying vec2 vUv;
    varying float vUvY;
    float random(vec2 st) { return fract(sin(dot(st, vec2(12.9898,78.233))) * 43758.5453123); }
    float noise(vec2 st) {
      vec2 i = floor(st);
      vec2 f = fract(st);
      vec2 u = f * f * (3.0 - 2.0 * f);
      return mix(
        mix(random(i), random(i + vec2(1.0,0.0)), u.x),
        mix(random(i + vec2(0.0,1.0)), random(i + vec2(1.0)), u.x),
        u.y
      );
    }
    void main() {
      vUv = uv;
      vUvY = uv.y;
      float n = noise(uv * 5.0 + uTime * 0.3);
      vec3 displaced = position + normal * n * 2.5;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(displaced, 1.0);
    }
  `;

  const fragmentShader = `
    uniform vec3 colorA;
    uniform vec3 colorB;
    uniform vec3 colorC;
    varying float vUvY;
    void main() {
      vec3 col = (vUvY < 0.5) ? mix(colorA, colorB, vUvY * 2.0)
                                : mix(colorB, colorC, (vUvY - 0.5) * 2.0);
      gl_FragColor = vec4(col, 1.0);
    }
  `;

  // Create bloom petals
  function createBloom(radius, petals, palette) {
    const group = new THREE.Group();
    petals = Math.max(3, petals);
    for (let i = 0; i < petals; i++) {
      const angle = (i / petals) * Math.PI * 2;
      const geom = createPetalGeometry(radius);
      geom.computeVertexNormals();
      const mat = createShaderMaterial(palette);
      const mesh = new THREE.Mesh(geom, mat);
      mesh.rotation.z = angle;
      group.add(mesh);
    }
    return group;
  }

  // Petal geometry via lathe
  function createPetalGeometry(radius) {
    const points = [];
    const seg = 16;
    for (let i = 0; i <= seg; i++) {
      const t = i / seg;
      const x = Math.sin(t * Math.PI) * radius;
      const y = Math.cos(t * Math.PI) * radius * 0.1;
      points.push(new THREE.Vector2(x, y));
    }
    return new THREE.LatheGeometry(points, 12);
  }

  // Resize handler
  function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    composer.setSize(window.innerWidth, window.innerHeight);
  }

  // Animation loop
  function animate() {
    requestAnimationFrame(animate);
    const t = clock.getElapsedTime();
    [bloomGroup, mushroomGroup, budGroup].forEach(group => {
      group.children.forEach(obj => {
        if (obj.material && obj.material.uniforms) obj.material.uniforms.uTime.value = t;
      });
    });
    bubbleGroup.children.forEach(b => {
      b.position.add(b.userData.vel);
      if (b.position.y > 60) b.position.y = -60;
    });
    composer.render();
  }
</script>
</body>
</html>
